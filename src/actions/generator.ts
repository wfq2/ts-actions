import type { ActionInput, ActionMetadata, ActionReference } from "./types.js";

const SPLIT_REGEX = /[-_]/;
const VERSION_PREFIX_REGEX = /^v/;

/**
 * Generate TypeScript type definition for action inputs
 */
export function generateInputType(metadata: ActionMetadata): string {
  if (!metadata.inputs || Object.keys(metadata.inputs).length === 0) {
    return "Record<string, never>";
  }

  const inputEntries = Object.entries(metadata.inputs);
  const typeProperties: string[] = [];

  for (const [key, input] of inputEntries) {
    const tsType = mapInputTypeToTypeScript(input);
    // A property is optional if it's not required OR if it has a default value
    const isOptional = !input.required || input.default !== undefined;
    const propertyName = key.includes("-") ? `"${key}"` : key;

    if (isOptional) {
      typeProperties.push(`  ${propertyName}?: ${tsType};`);
    } else {
      typeProperties.push(`  ${propertyName}: ${tsType};`);
    }
  }

  return `{\n${typeProperties.join("\n")}\n}`;
}

/**
 * Generate TypeScript type definition for action outputs
 */
export function generateOutputType(metadata: ActionMetadata): string {
  if (!metadata.outputs || Object.keys(metadata.outputs).length === 0) {
    return "Record<string, never>";
  }

  const outputEntries = Object.entries(metadata.outputs);
  const typeProperties: string[] = [];

  for (const [key] of outputEntries) {
    const propertyName = key.includes("-") ? `"${key}"` : key;
    typeProperties.push(`  ${propertyName}: string;`);
  }

  return `{\n${typeProperties.join("\n")}\n}`;
}

/**
 * Map action input type to TypeScript type
 */
function mapInputTypeToTypeScript(input: ActionInput): string {
  // If type is explicitly specified, use it
  if (input.type) {
    switch (input.type) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      default:
        return "string";
    }
  }

  // Infer type from default value if available
  if (input.default !== undefined) {
    if (typeof input.default === "boolean") {
      return "boolean";
    }
    if (typeof input.default === "number") {
      return "number";
    }
    return "string";
  }

  // Default to string
  return "string";
}

/**
 * Generate complete TypeScript type definition file for an action
 */
export function generateTypeDefinition(
  metadata: ActionMetadata,
  actionName: string,
  reference: ActionReference
): string {
  const inputType = generateInputType(metadata);
  const outputType = generateOutputType(metadata);
  const githubUrl = `https://github.com/${reference.owner}/${reference.repo}`;

  return `/**
 * Type definitions for ${actionName}
 * 
 * Generated from action.yml
 * DO NOT EDIT THIS FILE MANUALLY
 * 
 * @see {@link ${githubUrl} GitHub Repository}
 */

export interface ${actionName}Inputs ${inputType}

export interface ${actionName}Outputs ${outputType}

export interface ${actionName}Metadata {
  inputs: ${actionName}Inputs;
  outputs: ${actionName}Outputs;
}

/**
 * Action class for ${reference.full}
 * 
 * This class represents the imported action and provides type-safe access
 * to the action reference string.
 * 
 * This is a static class - use the class directly, no instantiation needed.
 * Example: step.uses(${actionName})
 * 
 * @see {@link ${githubUrl} GitHub Repository}
 */
class ${actionName}Impl {
  /**
   * The action reference string (e.g., "actions/checkout@v4")
   * This is a static property - access it via the class: ${actionName}.reference
   */
  static readonly reference: string = "${reference.full}";
  
  /**
   * Private constructor to prevent instantiation
   * Use the class directly as a static reference
   */
  private constructor() {}
}

// Export the class with the reference property on the constructor
// This allows TypeScript to recognize the reference property on the class itself
// Use 'as const' assertion to preserve the literal type of the reference string
/**
 * Action class for ${reference.full}
 * 
 * This class represents the imported action and provides type-safe access
 * to the action reference string.
 * 
 * This is a static class - use the class directly, no instantiation needed.
 * Example: step.uses(${actionName})
 * 
 * @see {@link ${githubUrl} GitHub Repository}
 */
export const ${actionName} = ${actionName}Impl as typeof ${actionName}Impl & { readonly reference: "${reference.full}" };

// Add reference property to the exported class for runtime access
Object.defineProperty(${actionName}, "reference", {
  value: "${reference.full}",
  writable: false,
  enumerable: true,
  configurable: false,
});
`;
}

/**
 * Generate a safe TypeScript identifier from an action reference
 * Example: "actions/checkout@v4" -> "ActionsCheckoutV4"
 */
export function generateActionTypeName(owner: string, repo: string, version: string): string {
  const capitalize = (str: string): string =>
    str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();

  const ownerParts = owner.split(SPLIT_REGEX).map(capitalize).join("");
  const repoParts = repo.split(SPLIT_REGEX).map(capitalize).join("");
  const versionParts = version
    .replace(VERSION_PREFIX_REGEX, "")
    .split(SPLIT_REGEX)
    .map(capitalize)
    .join("");

  return `${ownerParts}${repoParts}${versionParts}`;
}
