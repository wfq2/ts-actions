{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ts-actions","text":"<p>TypeScript library for programmatically creating GitHub Actions workflows using a type-safe API</p> <p>ts-actions provides a fluent, type-safe API for building GitHub Actions workflows in TypeScript, similar to how cdk8s works for Kubernetes.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Type-safe: Full TypeScript support with comprehensive type definitions</li> <li>Multi-language: Supports TypeScript/JavaScript and Python (via jsii)</li> <li>Fluent API: Chainable methods for building workflows</li> <li>YAML Generation: Automatically generates valid GitHub Actions YAML files</li> <li>CLI Tool: Command-line interface for synthesizing workflows</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import { Workflow, Job, Step, synthesize } from \"ts-actions\";\n\nconst workflow = new Workflow(\"CI\")\n  .onPush({ branches: [\"main\"] })\n  .addJob(\"build\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .addStep((step) =&gt;\n        step\n          .name(\"Checkout code\")\n          .uses(\"actions/checkout@v4\")\n      )\n      .addStep((step) =&gt;\n        step\n          .name(\"Run tests\")\n          .run(\"npm test\")\n      )\n  );\n\n// Synthesize to YAML\nawait synthesize(workflow, \".github/workflows\");\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>=== \"npm\"</p> <pre><code>```bash\nnpm install ts-actions\n```\n</code></pre> <p>=== \"pip\"</p> <pre><code>```bash\npip install ts-actions\n```\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to get started? Head over to the Installation guide and then check out the Quick Start tutorial.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Examples - Code examples and patterns</li> <li>GitHub Repository - Source code and issues</li> </ul>"},{"location":"#license","title":"License","text":"<p>ISC</p>"},{"location":"api/helpers/","title":"Helper Functions","text":"<p>ts-actions provides several helper functions to make working with workflows easier and more type-safe.</p>"},{"location":"api/helpers/#job-outputs","title":"Job Outputs","text":""},{"location":"api/helpers/#needsjob-jobtoutputs-joboutputsreftoutputs","title":"<code>needs(job: Job&lt;TOutputs&gt;): JobOutputsRef&lt;TOutputs&gt;</code>","text":""},{"location":"api/helpers/#needsjobs-jobtoutputs-joboutputsreftoutputs","title":"<code>needs(...jobs: Job&lt;TOutputs&gt;[]): JobOutputsRef&lt;TOutputs&gt;[]</code>","text":"<p>Creates a type-safe reference to a job's outputs. This allows you to access job outputs with full TypeScript autocomplete and type checking.</p> <p>Parameters: - <code>job</code> or <code>jobs</code>: One or more Job instances that have outputs defined and an ID set</p> <p>Returns: A job output reference object (or array) with: - <code>id</code>: The job ID for use in <code>.needs()</code> - <code>outputs</code>: An object with type-safe access to job outputs</p> <p>Example:</p> <pre><code>import { needs } from \"ts-actions\";\n\nconst buildJob = new Job(\"ubuntu-latest\")\n  .outputs({\n    artifact: \"${{ steps.build.outputs.path }}\",\n    version: \"${{ steps.version.outputs.version }}\"\n  });\n\n// Add job to workflow first\nworkflow.addJob(\"build\", buildJob);\n\n// Create a reference\nconst buildRef = needs(buildJob);\n\n// Use in another job\nconst deployJob = new Job(\"ubuntu-latest\")\n  .needs(buildRef) // Type-safe job dependency\n  .addStep((step) =&gt;\n    step.run(`echo \"Deploying version ${buildRef.outputs.version}\"`)\n  );\n</code></pre>"},{"location":"api/helpers/#stepstoutputsstepid-string-stepoutputstoutputs","title":"<code>steps&lt;TOutputs&gt;(stepId: string): StepOutputs&lt;TOutputs&gt;</code>","text":"<p>Creates a type-safe reference to a step's outputs.</p> <p>Parameters: - <code>stepId</code>: The step ID (must match the step's <code>id()</code> value) - <code>TOutputs</code> (generic): Type parameter describing the step's outputs</p> <p>Returns: An object with type-safe access to step outputs</p> <p>Example:</p> <pre><code>import { steps } from \"ts-actions\";\n\nconst step = new Step()\n  .id(\"get-version\")\n  .name(\"Get Version\")\n  .run(\"echo 'version=1.0.0' &gt;&gt; $GITHUB_OUTPUT\");\n\n// Later, reference the step outputs\nconst versionRef = steps&lt;{ version: string }&gt;(\"get-version\");\n\nconst nextStep = new Step()\n  .name(\"Use Version\")\n  .run(`echo \"Version is ${versionRef.outputs.version}\"`);\n</code></pre>"},{"location":"api/helpers/#setoutputname-string-value-string-number-boolean-string","title":"<code>setOutput(name: string, value: string | number | boolean): string</code>","text":"<p>Generates the shell command to set a step output in GitHub Actions. This is a convenience function that properly escapes values.</p> <p>Parameters: - <code>name</code>: The output name - <code>value</code>: The output value (string, number, or boolean)</p> <p>Returns: The shell command string that sets the output</p> <p>Example:</p> <pre><code>import { setOutput } from \"ts-actions\";\n\nconst step = new Step()\n  .id(\"get-info\")\n  .name(\"Get Information\")\n  .run([\n    \"VERSION=$(node -p \\\"require('./package.json').version\\\")\",\n    setOutput(\"version\", \"$VERSION\"),\n    setOutput(\"timestamp\", \"$(date +%s)\"),\n    setOutput(\"deployed\", true)\n  ].join(\"\\n\"));\n</code></pre>"},{"location":"api/helpers/#run-name-helpers","title":"Run Name Helpers","text":"<p>These functions help create structured and informative GitHub Actions run names.</p>"},{"location":"api/helpers/#defaultrunname-githubexpression","title":"<code>defaultRunName(): GitHubExpression</code>","text":"<p>Creates a structured run name that includes workflow name, commit message, and actor.</p> <p>Returns: A GitHub Actions expression string</p> <p>Example:</p> <pre><code>import { defaultRunName } from \"ts-actions\";\n\nworkflow.runName(defaultRunName());\n// Generates: \"${{ github.workflow }}: ${{ github.event.head_commit.message }} by @${{ github.actor }}\"\n</code></pre>"},{"location":"api/helpers/#runnamewithcommit-githubexpression","title":"<code>runNameWithCommit(): GitHubExpression</code>","text":"<p>Creates a run name with workflow name and commit message only.</p> <p>Returns: A GitHub Actions expression string</p> <p>Example:</p> <pre><code>import { runNameWithCommit } from \"ts-actions\";\n\nworkflow.runName(runNameWithCommit());\n// Generates: \"${{ github.workflow }} - ${{ github.event.head_commit.message }}\"\n</code></pre>"},{"location":"api/helpers/#runnamewithbranch-githubexpression","title":"<code>runNameWithBranch(): GitHubExpression</code>","text":"<p>Creates a run name with workflow name, branch, and actor.</p> <p>Returns: A GitHub Actions expression string</p> <p>Example:</p> <pre><code>import { runNameWithBranch } from \"ts-actions\";\n\nworkflow.runName(runNameWithBranch());\n// Generates: \"${{ github.workflow }} on ${{ github.ref_name }} by @${{ github.actor }}\"\n</code></pre>"},{"location":"api/helpers/#runnamewithsha-githubexpression","title":"<code>runNameWithSha(): GitHubExpression</code>","text":"<p>Creates a run name with workflow name, commit SHA (short), and commit message.</p> <p>Returns: A GitHub Actions expression string</p> <p>Example:</p> <pre><code>import { runNameWithSha } from \"ts-actions\";\n\nworkflow.runName(runNameWithSha());\n// Generates: \"${{ github.workflow }} [${{ github.event.head_commit.id }}] ${{ github.event.head_commit.message }}\"\n</code></pre>"},{"location":"api/helpers/#customrunnametemplate-string-githubexpression","title":"<code>customRunName(template: string): GitHubExpression</code>","text":"<p>Creates a custom run name using a template string with GitHub context variables.</p> <p>Parameters: - <code>template</code>: Template string with GitHub Actions expressions</p> <p>Returns: A GitHub Actions expression string</p> <p>Example:</p> <pre><code>import { customRunName } from \"ts-actions\";\n\nworkflow.runName(\n  customRunName(\"${{ github.workflow }} - PR #${{ github.event.pull_request.number }}\")\n);\n</code></pre>"},{"location":"api/helpers/#expression-helper","title":"Expression Helper","text":""},{"location":"api/helpers/#exprvalue-string-githubexpression","title":"<code>expr(value: string): GitHubExpression</code>","text":"<p>Helper function to create a GitHubExpression from a string. This is useful when passing GitHub Actions expressions to functions that accept typed parameters.</p> <p>Parameters: - <code>value</code>: A string containing a GitHub Actions expression</p> <p>Returns: A typed GitHubExpression</p> <p>Example:</p> <pre><code>import { expr } from \"ts-actions\";\n\nfunction processData(input: string): void {\n  // ...\n}\n\nconst step = new Step()\n  .runTypeScript(\n    processData,\n    expr(\"${{ steps.get-value.outputs.data }}\")\n  );\n</code></pre> <p>Note: This function is mainly used internally. In most cases, you can pass expression strings directly and TypeScript will accept them.</p>"},{"location":"api/helpers/#complete-example","title":"Complete Example","text":"<pre><code>import {\n  Workflow,\n  Job,\n  Step,\n  needs,\n  steps,\n  setOutput,\n  defaultRunName,\n  expr\n} from \"ts-actions\";\n\nconst workflow = new Workflow(\"CI/CD\")\n  .runName(defaultRunName())\n  .addJob(\"build\", (job) =&gt; {\n    const buildStep = new Step()\n      .id(\"build\")\n      .name(\"Build\")\n      .run([\n        \"npm run build\",\n        setOutput(\"artifact\", \"./dist/app.zip\")\n      ].join(\"\\n\"));\n\n    const versionStep = new Step()\n      .id(\"get-version\")\n      .name(\"Get Version\")\n      .run([\n        \"VERSION=$(node -p \\\"require('./package.json').version\\\")\",\n        setOutput(\"version\", \"$VERSION\")\n      ].join(\"\\n\"));\n\n    return job\n      .outputs({\n        artifact: \"${{ steps.build.outputs.artifact }}\",\n        version: \"${{ steps.get-version.outputs.version }}\"\n      })\n      .addStep(buildStep)\n      .addStep(versionStep);\n  })\n  .addJob(\"deploy\", (job) =&gt; {\n    const buildRef = needs(/* build job reference */);\n\n    return job\n      .needs(buildRef)\n      .addStep((step) =&gt;\n        step\n          .name(\"Deploy\")\n          .run(`echo \"Deploying version ${buildRef.outputs.version}\"`)\n      );\n  });\n</code></pre>"},{"location":"api/job/","title":"Job","text":"<p>The <code>Job</code> class represents a GitHub Actions job. Jobs define the steps that run on a specific runner, along with job-level configuration like dependencies, conditions, and environment variables.</p>"},{"location":"api/job/#constructor","title":"Constructor","text":""},{"location":"api/job/#new-jobtoutputsrunson-runner-runner","title":"<code>new Job&lt;TOutputs&gt;(runsOn: Runner | Runner[])</code>","text":"<p>Creates a new job instance.</p> <p>Parameters: - <code>runsOn</code>: The runner(s) to use for this job. Can be a single runner string or an array of runners. Common values include:   - <code>\"ubuntu-latest\"</code>, <code>\"ubuntu-22.04\"</code>, <code>\"ubuntu-20.04\"</code>   - <code>\"windows-latest\"</code>, <code>\"windows-2022\"</code>, <code>\"windows-2019\"</code>   - <code>\"macos-latest\"</code>, <code>\"macos-14\"</code>, <code>\"macos-13\"</code>   - Any custom runner label as a string - <code>TOutputs</code> (generic): Optional type parameter for type-safe job outputs</p> <p>Returns: A new <code>Job</code> instance</p> <p>Example:</p> <pre><code>const job = new Job(\"ubuntu-latest\");\n</code></pre>"},{"location":"api/job/#methods","title":"Methods","text":""},{"location":"api/job/#runsonrunner-runner-runner-this","title":"<code>runsOn(runner: Runner | Runner[]): this</code>","text":"<p>Sets the runner(s) for this job. Overrides the runner specified in the constructor.</p> <p>Parameters: - <code>runner</code>: The runner(s) to use (same format as constructor)</p> <p>Returns: The job instance for method chaining</p> <p>Example:</p> <pre><code>job.runsOn([\"ubuntu-latest\", \"windows-latest\"]);\n</code></pre>"},{"location":"api/job/#namename-string-this","title":"<code>name(name: string): this</code>","text":"<p>Sets a descriptive display name for this job. This appears in the GitHub Actions UI.</p> <p>Parameters: - <code>name</code>: The display name for the job</p> <p>Returns: The job instance for method chaining</p> <p>Example:</p> <pre><code>job.name(\"Build and Test Application\");\n</code></pre>"},{"location":"api/job/#needsdependencies-this","title":"<code>needs(dependencies): this</code>","text":"<p>Sets job dependencies. This job will wait for the specified jobs to complete before running.</p> <p>Parameters: - <code>dependencies</code>: Can be one of:   - A single job ID string: <code>\"job-name\"</code>   - An array of job ID strings: <code>[\"job1\", \"job2\"]</code>   - A job reference created with <code>needs()</code>: <code>needs(jobInstance)</code>   - An array of job references: <code>[needs(job1), needs(job2)]</code></p> <p>Returns: The job instance for method chaining</p> <p>Example:</p> <pre><code>// Using job ID strings\njob.needs(\"lint\");\njob.needs([\"lint\", \"build\"]);\n\n// Using job references (type-safe)\nimport { needs } from \"ts-actions\";\nconst lintJob = new Job(\"ubuntu-latest\") /* ... */;\njob.needs(needs(lintJob));\n</code></pre>"},{"location":"api/job/#ifcondition-string-this","title":"<code>if(condition: string): this</code>","text":"<p>Sets a conditional expression for this job. The job will only run if the condition evaluates to true.</p> <p>Parameters: - <code>condition</code>: A GitHub Actions expression that evaluates to a boolean</p> <p>Returns: The job instance for method chaining</p> <p>Example:</p> <pre><code>job.if(\"github.ref == 'refs/heads/main'\");\njob.if(\"github.event.inputs.environment == 'production'\");\n</code></pre>"},{"location":"api/job/#addstepsteps-this","title":"<code>addStep(...steps): this</code>","text":"<p>Adds step(s) to this job. Can accept Step instances or functions that configure steps.</p> <p>Parameters: - <code>steps</code>: One or more steps, where each step can be:   - A <code>Step</code> instance   - A function that receives a <code>Step</code> and returns a configured <code>Step</code>   - An array of steps (which will be flattened)</p> <p>Returns: The job instance for method chaining</p> <p>Example:</p> <pre><code>// Using functions\njob.addStep((step) =&gt;\n  step.name(\"Checkout\").uses(\"actions/checkout@v4\")\n);\n\n// Adding multiple steps\njob.addStep(\n  (step) =&gt; step.name(\"Step 1\").run(\"echo 'Step 1'\"),\n  (step) =&gt; step.name(\"Step 2\").run(\"echo 'Step 2'\")\n);\n\n// Using Step instances\nconst step1 = new Step().name(\"Step 1\").run(\"echo 'Step 1'\");\njob.addStep(step1);\n</code></pre>"},{"location":"api/job/#outputstoutputkeysoutputs-toutputkeys-jobtoutputs-toutputkeys","title":"<code>outputs&lt;TOutputKeys&gt;(outputs: TOutputKeys): Job&lt;TOutputs &amp; TOutputKeys&gt;</code>","text":"<p>Defines outputs for this job. Outputs can be accessed by other jobs using <code>needs()</code>.</p> <p>Parameters: - <code>outputs</code>: An object mapping output names to GitHub Actions expressions that produce their values</p> <p>Returns: A new Job instance with updated output types (for type safety)</p> <p>Example:</p> <pre><code>const job = new Job(\"ubuntu-latest\")\n  .outputs({\n    version: \"${{ steps.get-version.outputs.version }}\",\n    artifact: \"${{ steps.build.outputs.path }}\"\n  });\n</code></pre> <p>See Helper Functions for more details on using job outputs.</p>"},{"location":"api/job/#envvariables-key-string-string-this","title":"<code>env(variables: { [key: string]: string }): this</code>","text":"<p>Sets environment variables for this job. These will be available to all steps in the job.</p> <p>Parameters: - <code>variables</code>: An object mapping environment variable names to their values</p> <p>Returns: The job instance for method chaining</p> <p>Example:</p> <pre><code>job.env({\n  NODE_ENV: \"production\",\n  API_KEY: \"${{ secrets.API_KEY }}\"\n});\n</code></pre>"},{"location":"api/job/#defaultsdefaults-ijobdefaults-this","title":"<code>defaults(defaults: IJobDefaults): this</code>","text":"<p>Sets default values for steps in this job.</p> <p>Parameters: - <code>defaults</code>: Default step settings   - <code>run</code>: Default run settings     - <code>shell</code>: Default shell     - <code>working-directory</code>: Default working directory</p> <p>Returns: The job instance for method chaining</p> <p>Example:</p> <pre><code>job.defaults({\n  run: {\n    shell: \"bash\",\n    \"working-directory\": \"./src\"\n  }\n});\n</code></pre>"},{"location":"api/job/#timeoutminutesminutes-number-this","title":"<code>timeoutMinutes(minutes: number): this</code>","text":"<p>Sets the maximum time (in minutes) the job is allowed to run before being cancelled.</p> <p>Parameters: - <code>minutes</code>: Timeout in minutes</p> <p>Returns: The job instance for method chaining</p> <p>Example:</p> <pre><code>job.timeoutMinutes(30);\n</code></pre>"},{"location":"api/job/#strategystrategy-ijobstrategy-this","title":"<code>strategy(strategy: IJobStrategy): this</code>","text":"<p>Sets the build matrix strategy for this job. This allows running the job with different variable combinations.</p> <p>Parameters: - <code>strategy</code>: Strategy configuration   - <code>matrix</code>: An object mapping variable names to arrays of values   - <code>fail-fast</code>: Whether to cancel remaining jobs if one fails (default: true)   - <code>max-parallel</code>: Maximum number of jobs to run in parallel</p> <p>Returns: The job instance for method chaining</p> <p>Example:</p> <pre><code>job.strategy({\n  matrix: {\n    node: [\"18\", \"20\", \"22\"],\n    os: [\"ubuntu-latest\", \"windows-latest\"]\n  },\n  \"fail-fast\": false,\n  \"max-parallel\": 3\n});\n</code></pre>"},{"location":"api/job/#continueonerrorcontinueonerror-true-this","title":"<code>continueOnError(continueOnError = true): this</code>","text":"<p>Sets whether this job should continue even if one of its steps fails.</p> <p>Parameters: - <code>continueOnError</code>: Whether to continue on error (default: true)</p> <p>Returns: The job instance for method chaining</p> <p>Example:</p> <pre><code>job.continueOnError(true);\n</code></pre>"},{"location":"api/job/#concurrencygroup-string-cancelinprogress-boolean-this","title":"<code>concurrency(group: string, cancelInProgress?: boolean): this</code>","text":"<p>Sets concurrency settings for this job. Jobs in the same concurrency group will be limited to a certain number of concurrent runs.</p> <p>Parameters: - <code>group</code>: The concurrency group name (can include GitHub Actions expressions) - <code>cancelInProgress</code> (optional): Whether to cancel in-progress runs when a new run starts (default: false)</p> <p>Returns: The job instance for method chaining</p> <p>Example:</p> <pre><code>job.concurrency(\"deployment-${{ github.ref }}\", true);\n</code></pre>"},{"location":"api/job/#tojson-ijob","title":"<code>toJSON(): IJob</code>","text":"<p>Converts the job to its JSON configuration format. This is used internally by the synthesis functions.</p> <p>Returns: The job configuration object</p>"},{"location":"api/job/#complete-example","title":"Complete Example","text":"<pre><code>import { Job, Step, needs } from \"ts-actions\";\n\nconst buildJob = new Job(\"ubuntu-latest\")\n  .name(\"Build Application\")\n  .outputs({\n    artifact: \"${{ steps.build.outputs.path }}\",\n    version: \"${{ steps.version.outputs.version }}\"\n  })\n  .env({ NODE_ENV: \"production\" })\n  .timeoutMinutes(30)\n  .addStep((step) =&gt;\n    step.name(\"Build\").run(\"npm run build\")\n  );\n\nconst testJob = new Job(\"ubuntu-latest\")\n  .name(\"Run Tests\")\n  .needs(needs(buildJob)) // Wait for build to complete\n  .if(\"github.ref == 'refs/heads/main'\") // Only run on main branch\n  .strategy({\n    matrix: {\n      node: [\"18\", \"20\", \"22\"]\n    }\n  })\n  .addStep((step) =&gt;\n    step.name(\"Test\").run(\"npm test\")\n  );\n</code></pre>"},{"location":"api/step/","title":"Step","text":"<p>The <code>Step</code> class represents a single step within a GitHub Actions job. Steps are the individual tasks that run sequentially within a job.</p>"},{"location":"api/step/#constructor","title":"Constructor","text":""},{"location":"api/step/#new-step","title":"<code>new Step()</code>","text":"<p>Creates a new step instance.</p> <p>Returns: A new <code>Step</code> instance</p> <p>Example:</p> <pre><code>const step = new Step();\n</code></pre>"},{"location":"api/step/#methods","title":"Methods","text":""},{"location":"api/step/#idid-string-this","title":"<code>id(id: string): this</code>","text":"<p>Sets a unique identifier for this step. The ID can be used to reference the step's outputs in other steps.</p> <p>Parameters: - <code>id</code>: The step identifier (must be unique within the job)</p> <p>Returns: The step instance for method chaining</p> <p>Example:</p> <pre><code>step.id(\"build-step\");\n</code></pre>"},{"location":"api/step/#namename-string-this","title":"<code>name(name: string): this</code>","text":"<p>Sets the display name for this step. This appears in the GitHub Actions UI.</p> <p>Parameters: - <code>name</code>: The step name</p> <p>Returns: The step instance for method chaining</p> <p>Example:</p> <pre><code>step.name(\"Build Application\");\n</code></pre>"},{"location":"api/step/#usesaction-iactionclasstype-this","title":"<code>uses(action: IActionClassType): this</code>","text":"<p>Sets the action to use for this step. When using <code>uses()</code>, you cannot use <code>run()</code> or <code>runTypeScript()</code>.</p> <p>Parameters: - <code>action</code>: An action class with a <code>reference</code> property (e.g., from imported action types)</p> <p>Returns: The step instance for method chaining</p> <p>Example:</p> <pre><code>// Using action classes (requires importing action types)\nstep.uses(CheckoutAction);\n</code></pre> <p>Note: Action type imports are an advanced feature. Most users will use action references as strings in <code>run()</code> commands or use standard actions directly.</p>"},{"location":"api/step/#runcommand-string-this","title":"<code>run(command: string): this</code>","text":"<p>Sets the command to run for this step. This is the most common way to execute commands. When using <code>run()</code>, you cannot use <code>uses()</code> or <code>runTypeScript()</code>.</p> <p>Parameters: - <code>command</code>: The shell command to execute</p> <p>Returns: The step instance for method chaining</p> <p>Example:</p> <pre><code>step.run(\"npm install\");\nstep.run(\"npm run build &amp;&amp; npm test\");\n</code></pre>"},{"location":"api/step/#runtypescriptfn-options-args-this","title":"<code>runTypeScript(fn, options?, ...args): this</code>","text":"<p>Runs a TypeScript function in this step. The function source will be extracted and transpiled during synthesis. This is useful for complex logic that would be difficult to write as shell commands.</p> <p>Parameters: - <code>fn</code>: The TypeScript function to execute - <code>options</code> (optional): Configuration options   - <code>nodeVersion</code>: Node.js version to use (default: \"24\") - <code>args</code>: Arguments to pass to the function (can include GitHub Actions expressions using <code>expr()</code>)</p> <p>Returns: The step instance for method chaining</p> <p>Example:</p> <pre><code>import { expr } from \"ts-actions\";\n\nfunction processData(input: string, multiplier: number): string {\n  return `${input} processed ${multiplier} times`;\n}\n\nstep.runTypeScript(processData, {\n  nodeVersion: \"20\"\n}, \"input-data\", expr(\"${{ steps.get-value.outputs.count }}\"));\n</code></pre> <p>Note: TypeScript function steps are processed during synthesis. The function source code is extracted and transpiled to JavaScript, then embedded in the workflow.</p>"},{"location":"api/step/#withinputsinputs-key-string-string-number-boolean-this","title":"<code>withInputs(inputs: { [key: string]: string | number | boolean }): this</code>","text":"<p>Sets input parameters for the action used in this step. This is only valid when using <code>uses()</code>.</p> <p>Parameters: - <code>inputs</code>: An object mapping input names to their values</p> <p>Returns: The step instance for method chaining</p> <p>Example:</p> <pre><code>step.uses(\"actions/setup-node@v4\")\n  .withInputs({ \"node-version\": \"20\" });\n</code></pre>"},{"location":"api/step/#withinputs-key-string-string-number-boolean-this","title":"<code>with(inputs: { [key: string]: string | number | boolean }): this</code>","text":"<p>Alias for <code>withInputs()</code>. Provided for backward compatibility and familiarity with GitHub Actions YAML syntax.</p> <p>Parameters: - <code>inputs</code>: An object mapping input names to their values</p> <p>Returns: The step instance for method chaining</p> <p>Example:</p> <pre><code>step.uses(\"actions/setup-node@v4\")\n  .with({ \"node-version\": \"20\" });\n</code></pre>"},{"location":"api/step/#envvariables-key-string-string-this","title":"<code>env(variables: { [key: string]: string }): this</code>","text":"<p>Sets environment variables for this step.</p> <p>Parameters: - <code>variables</code>: An object mapping environment variable names to their values (can include GitHub Actions expressions)</p> <p>Returns: The step instance for method chaining</p> <p>Example:</p> <pre><code>step.env({\n  NODE_ENV: \"production\",\n  API_KEY: \"${{ secrets.API_KEY }}\"\n});\n</code></pre>"},{"location":"api/step/#continueonerrorcontinueonerror-true-this","title":"<code>continueOnError(continueOnError = true): this</code>","text":"<p>Sets whether this step should continue even if it fails. This prevents the job from failing if this step fails.</p> <p>Parameters: - <code>continueOnError</code>: Whether to continue on error (default: true)</p> <p>Returns: The step instance for method chaining</p> <p>Example:</p> <pre><code>step.continueOnError(true);\n</code></pre>"},{"location":"api/step/#timeoutminutesminutes-number-this","title":"<code>timeoutMinutes(minutes: number): this</code>","text":"<p>Sets the maximum time (in minutes) the step is allowed to run before being cancelled.</p> <p>Parameters: - <code>minutes</code>: Timeout in minutes</p> <p>Returns: The step instance for method chaining</p> <p>Example:</p> <pre><code>step.timeoutMinutes(10);\n</code></pre>"},{"location":"api/step/#ifconditioncondition-string-this","title":"<code>ifCondition(condition: string): this</code>","text":"<p>Sets a conditional expression for this step. The step will only run if the condition evaluates to true.</p> <p>Parameters: - <code>condition</code>: A GitHub Actions expression that evaluates to a boolean</p> <p>Returns: The step instance for method chaining</p> <p>Example:</p> <pre><code>step.ifCondition(\"github.ref == 'refs/heads/main'\");\n</code></pre>"},{"location":"api/step/#ifcondition-string-this","title":"<code>if(condition: string): this</code>","text":"<p>Alias for <code>ifCondition()</code>. Provided for backward compatibility and familiarity with GitHub Actions YAML syntax.</p> <p>Parameters: - <code>condition</code>: A GitHub Actions expression that evaluates to a boolean</p> <p>Returns: The step instance for method chaining</p> <p>Example:</p> <pre><code>step.if(\"github.ref == 'refs/heads/main'\");\n</code></pre>"},{"location":"api/step/#workingdirectorydirectory-string-this","title":"<code>workingDirectory(directory: string): this</code>","text":"<p>Sets the working directory for this step. Commands will be executed in this directory.</p> <p>Parameters: - <code>directory</code>: The working directory path</p> <p>Returns: The step instance for method chaining</p> <p>Example:</p> <pre><code>step.workingDirectory(\"./src\");\n</code></pre>"},{"location":"api/step/#tojson-istep","title":"<code>toJSON(): IStep</code>","text":"<p>Converts the step to its JSON configuration format. This is used internally by the synthesis functions.</p> <p>Returns: The step configuration object</p>"},{"location":"api/step/#complete-examples","title":"Complete Examples","text":""},{"location":"api/step/#basic-step","title":"Basic Step","text":"<pre><code>const step = new Step()\n  .name(\"Install Dependencies\")\n  .run(\"npm install\");\n</code></pre>"},{"location":"api/step/#step-with-action","title":"Step with Action","text":"<pre><code>const step = new Step()\n  .name(\"Checkout Code\")\n  .uses(\"actions/checkout@v4\")\n  .with({ ref: \"main\" });\n</code></pre>"},{"location":"api/step/#step-with-environment-variables","title":"Step with Environment Variables","text":"<pre><code>const step = new Step()\n  .name(\"Deploy\")\n  .run(\"npm run deploy\")\n  .env({\n    NODE_ENV: \"production\",\n    API_URL: \"${{ secrets.API_URL }}\"\n  })\n  .if(\"github.ref == 'refs/heads/main'\");\n</code></pre>"},{"location":"api/step/#step-with-outputs","title":"Step with Outputs","text":"<pre><code>import { setOutput } from \"ts-actions\";\n\nconst step = new Step()\n  .id(\"get-version\")\n  .name(\"Get Version\")\n  .run([\n    \"VERSION=$(node -p \\\"require('./package.json').version\\\")\",\n    setOutput(\"version\", \"$VERSION\")\n  ].join(\"\\n\"));\n</code></pre>"},{"location":"api/step/#typescript-function-step","title":"TypeScript Function Step","text":"<pre><code>import { expr } from \"ts-actions\";\n\nfunction generateConfig(env: string, port: number): string {\n  return JSON.stringify({ environment: env, port });\n}\n\nconst step = new Step()\n  .name(\"Generate Config\")\n  .runTypeScript(\n    generateConfig,\n    { nodeVersion: \"20\" },\n    expr(\"${{ github.event.inputs.environment }}\"),\n    8080\n  );\n</code></pre>"},{"location":"api/synthesis/","title":"Synthesis Functions","text":"<p>The synthesis functions convert workflow definitions into GitHub Actions YAML files. These functions process TypeScript function steps, convert workflows to JSON, and write YAML files to disk.</p>"},{"location":"api/synthesis/#functions","title":"Functions","text":""},{"location":"api/synthesis/#synthesizeworkflow-workflow-outputdir-string-promisevoid","title":"<code>synthesize(workflow: Workflow, outputDir?: string): Promise&lt;void&gt;</code>","text":"<p>Synthesizes a single workflow to a YAML file. The filename is automatically generated from the workflow name.</p> <p>Parameters: - <code>workflow</code>: The workflow instance to synthesize - <code>outputDir</code> (optional): The output directory for the YAML file (default: <code>\"dist\"</code>)</p> <p>Returns: A Promise that resolves when the file has been written</p> <p>Example:</p> <pre><code>import { Workflow, synthesize } from \"ts-actions\";\n\nconst workflow = new Workflow(\"CI\")\n  .onPush({ branches: [\"main\"] })\n  .addJob(\"test\", (job) =&gt; /* ... */);\n\n// Synthesize to default directory (dist/)\nawait synthesize(workflow);\n\n// Synthesize to custom directory\nawait synthesize(workflow, \".github/workflows\");\n</code></pre> <p>The generated filename will be based on the workflow name: - Workflow name: <code>\"CI\"</code> \u2192 Filename: <code>ci.yml</code> - Workflow name: <code>\"Build and Test\"</code> \u2192 Filename: <code>build-and-test.yml</code></p>"},{"location":"api/synthesis/#synthesizemultipleworkflows-array-workflow-workflow-filename-string-outputdir-string-promisevoid","title":"<code>synthesizeMultiple(workflows: Array&lt;{ workflow: Workflow; filename?: string }&gt;, outputDir?: string): Promise&lt;void&gt;</code>","text":"<p>Synthesizes multiple workflows to YAML files. This is useful when you have multiple workflows in a single file and want to generate them all at once.</p> <p>Parameters: - <code>workflows</code>: An array of objects, each containing:   - <code>workflow</code>: The workflow instance to synthesize   - <code>filename</code> (optional): Custom filename (without <code>.yml</code> extension). If not provided, the filename is generated from the workflow name. - <code>outputDir</code> (optional): The output directory for the YAML files (default: <code>\"dist\"</code>)</p> <p>Returns: A Promise that resolves when all files have been written</p> <p>Example:</p> <pre><code>import { Workflow, synthesizeMultiple } from \"ts-actions\";\n\nconst ciWorkflow = new Workflow(\"CI\") /* ... */;\nconst deployWorkflow = new Workflow(\"Deploy\") /* ... */;\n\n// Synthesize multiple workflows\nawait synthesizeMultiple([\n  { workflow: ciWorkflow },\n  { workflow: deployWorkflow, filename: \"production-deploy\" }\n], \".github/workflows\");\n</code></pre> <p>This will generate: - <code>ci.yml</code> (from workflow name) - <code>production-deploy.yml</code> (custom filename)</p>"},{"location":"api/synthesis/#how-it-works","title":"How It Works","text":"<ol> <li> <p>TypeScript Function Processing: If the workflow contains steps with <code>runTypeScript()</code>, the function source code is extracted and transpiled to JavaScript during synthesis.</p> </li> <li> <p>JSON Conversion: The workflow is converted to its JSON representation using <code>workflow.toJSON()</code>.</p> </li> <li> <p>YAML Generation: The JSON is converted to YAML format with proper indentation.</p> </li> <li> <p>File Writing: The YAML content is written to a file in the specified output directory. The directory is created if it doesn't exist.</p> </li> </ol>"},{"location":"api/synthesis/#complete-example","title":"Complete Example","text":"<pre><code>import {\n  Workflow,\n  Job,\n  Step,\n  synthesize,\n  synthesizeMultiple\n} from \"ts-actions\";\n\n// Single workflow\nconst ciWorkflow = new Workflow(\"CI\")\n  .onPush({ branches: [\"main\"] })\n  .addJob(\"test\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .addStep((step) =&gt;\n        step.name(\"Test\").run(\"npm test\")\n      )\n  );\n\nawait synthesize(ciWorkflow, \".github/workflows\");\n\n// Multiple workflows\nconst workflows = [\n  { workflow: ciWorkflow },\n  {\n    workflow: new Workflow(\"Lint\")\n      .onPullRequest()\n      .addJob(\"lint\", (job) =&gt; /* ... */),\n    filename: \"code-quality\" // Custom filename\n  }\n];\n\nawait synthesizeMultiple(workflows, \".github/workflows\");\n</code></pre>"},{"location":"api/synthesis/#notes","title":"Notes","text":"<ul> <li>Both functions are asynchronous and return Promises. Use <code>await</code> or <code>.then()</code> to wait for completion.</li> <li>The output directory will be created automatically if it doesn't exist.</li> <li>Filenames are sanitized (converted to lowercase, spaces replaced with hyphens).</li> <li>If a filename already includes the <code>.yml</code> extension, it won't be duplicated.</li> </ul>"},{"location":"api/types/","title":"Types and Interfaces","text":"<p>This page documents the TypeScript types and interfaces used throughout ts-actions.</p>"},{"location":"api/types/#core-types","title":"Core Types","text":""},{"location":"api/types/#jobid","title":"<code>JobId</code>","text":"<p>Type alias for job identifiers.</p> <pre><code>type JobId = string;\n</code></pre>"},{"location":"api/types/#runner","title":"<code>Runner</code>","text":"<p>Union type representing valid GitHub Actions runners.</p> <pre><code>type Runner =\n  | \"ubuntu-latest\"\n  | \"ubuntu-22.04\"\n  | \"ubuntu-20.04\"\n  | \"windows-latest\"\n  | \"windows-2022\"\n  | \"windows-2019\"\n  | \"macos-latest\"\n  | \"macos-14\"\n  | \"macos-13\"\n  | string;\n</code></pre> <p>Custom runner labels can also be used as strings.</p>"},{"location":"api/types/#githubexpression","title":"<code>GitHubExpression</code>","text":"<p>Branded type for GitHub Actions expression strings. Used to provide type safety when passing expressions to functions.</p> <pre><code>type GitHubExpression = string &amp; { readonly __brand: unique symbol };\n</code></pre> <p>Create expressions using the <code>expr()</code> helper function:</p> <pre><code>import { expr } from \"ts-actions\";\n\nconst expression = expr(\"${{ steps.id.outputs.value }}\");\n</code></pre>"},{"location":"api/types/#workflow-types","title":"Workflow Types","text":""},{"location":"api/types/#iworkflowtrigger","title":"<code>IWorkflowTrigger</code>","text":"<p>Configuration for workflow triggers.</p> <pre><code>interface IWorkflowTrigger {\n  push?: IPushTriggerConfig;\n  pull_request?: IPullRequestTriggerConfig;\n  workflow_dispatch?: IWorkflowDispatchConfig;\n  schedule?: IScheduleConfig[];\n  repository_dispatch?: IRepositoryDispatchConfig;\n  workflow_call?: IWorkflowCallConfig;\n}\n</code></pre>"},{"location":"api/types/#ipushtriggeroptions","title":"<code>IPushTriggerOptions</code>","text":"<p>Options for push triggers.</p> <pre><code>interface IPushTriggerOptions {\n  branches?: string[];\n  tags?: string[];\n  paths?: string[];\n  pathsIgnore?: string[];\n}\n</code></pre>"},{"location":"api/types/#ipullrequesttriggeroptions","title":"<code>IPullRequestTriggerOptions</code>","text":"<p>Options for pull request triggers.</p> <pre><code>interface IPullRequestTriggerOptions {\n  branches?: string[];\n  tags?: string[];\n  paths?: string[];\n  pathsIgnore?: string[];\n  types?: (\n    | \"opened\"\n    | \"synchronize\"\n    | \"reopened\"\n    | \"closed\"\n    | \"ready_for_review\"\n    | \"labeled\"\n    | \"unlabeled\"\n  )[];\n}\n</code></pre>"},{"location":"api/types/#iworkflowdispatchinput","title":"<code>IWorkflowDispatchInput</code>","text":"<p>Input definition for workflow dispatch.</p> <pre><code>interface IWorkflowDispatchInput {\n  description: string;\n  required?: boolean;\n  default?: string;\n  type?: \"string\" | \"choice\" | \"boolean\" | \"number\" | \"environment\";\n  options?: string[];\n}\n</code></pre>"},{"location":"api/types/#iworkflowcalloptions","title":"<code>IWorkflowCallOptions</code>","text":"<p>Options for reusable workflows (workflow_call).</p> <pre><code>interface IWorkflowCallOptions {\n  inputs?: { [key: string]: IWorkflowCallInput };\n  outputs?: { [key: string]: IWorkflowCallOutput };\n  secrets?: string[];\n}\n</code></pre>"},{"location":"api/types/#iworkflowpermissions","title":"<code>IWorkflowPermissions</code>","text":"<p>Workflow permission settings.</p> <pre><code>interface IWorkflowPermissions {\n  actions?: \"read\" | \"write\" | \"none\";\n  checks?: \"read\" | \"write\" | \"none\";\n  contents?: \"read\" | \"write\" | \"none\";\n  deployments?: \"read\" | \"write\" | \"none\";\n  \"id-token\"?: \"read\" | \"write\" | \"none\";\n  issues?: \"read\" | \"write\" | \"none\";\n  discussions?: \"read\" | \"write\" | \"none\";\n  packages?: \"read\" | \"write\" | \"none\";\n  pages?: \"read\" | \"write\" | \"none\";\n  \"pull-requests\"?: \"read\" | \"write\" | \"none\";\n  \"repository-projects\"?: \"read\" | \"write\" | \"none\";\n  \"security-events\"?: \"read\" | \"write\" | \"none\";\n  statuses?: \"read\" | \"write\" | \"none\";\n}\n</code></pre>"},{"location":"api/types/#iworkflowconfig","title":"<code>IWorkflowConfig</code>","text":"<p>Complete workflow configuration (output of <code>workflow.toJSON()</code>).</p> <pre><code>interface IWorkflowConfig {\n  name?: string;\n  on: IWorkflowTrigger;\n  jobs: { [jobId: string]: Job };\n  env?: { [key: string]: string };\n  defaults?: IJobDefaults;\n  permissions?: IWorkflowPermissions;\n  \"run-name\"?: string;\n}\n</code></pre>"},{"location":"api/types/#job-types","title":"Job Types","text":""},{"location":"api/types/#ijob","title":"<code>IJob</code>","text":"<p>Job configuration.</p> <pre><code>interface IJob {\n  \"runs-on\": Runner | Runner[];\n  name?: string;\n  needs?: string | string[];\n  if?: string;\n  steps: IStep[];\n  outputs?: { [key: string]: string };\n  env?: { [key: string]: string };\n  defaults?: IJobDefaults;\n  \"timeout-minutes\"?: number;\n  strategy?: IJobStrategy;\n  \"continue-on-error\"?: boolean;\n  concurrency?: IJobConcurrency;\n}\n</code></pre>"},{"location":"api/types/#ijobdefaults","title":"<code>IJobDefaults</code>","text":"<p>Default settings for job steps.</p> <pre><code>interface IJobDefaults {\n  run?: {\n    shell?: string;\n    \"working-directory\"?: string;\n  };\n}\n</code></pre>"},{"location":"api/types/#ijobstrategy","title":"<code>IJobStrategy</code>","text":"<p>Build matrix strategy configuration.</p> <pre><code>interface IJobStrategy {\n  matrix?: { [key: string]: (string | number)[] };\n  \"fail-fast\"?: boolean;\n  \"max-parallel\"?: number;\n}\n</code></pre>"},{"location":"api/types/#ijobconcurrency","title":"<code>IJobConcurrency</code>","text":"<p>Job concurrency settings.</p> <pre><code>interface IJobConcurrency {\n  group?: string;\n  \"cancel-in-progress\"?: boolean;\n}\n</code></pre>"},{"location":"api/types/#step-types","title":"Step Types","text":""},{"location":"api/types/#istep","title":"<code>IStep</code>","text":"<p>Step configuration.</p> <pre><code>interface IStep {\n  id?: string;\n  name?: string;\n  uses?: string;\n  run?: string;\n  with?: { [key: string]: string | number | boolean };\n  env?: { [key: string]: string };\n  \"continue-on-error\"?: boolean;\n  \"timeout-minutes\"?: number;\n  if?: string;\n  \"working-directory\"?: string;\n}\n</code></pre>"},{"location":"api/types/#itypescriptstepoptions","title":"<code>ITypeScriptStepOptions</code>","text":"<p>Options for TypeScript function steps.</p> <pre><code>interface ITypeScriptStepOptions {\n  nodeVersion?: string; // Default: \"24\"\n}\n</code></pre>"},{"location":"api/types/#typescriptfunction","title":"<code>TypeScriptFunction</code>","text":"<p>Type for TypeScript functions that can be executed in workflow steps.</p> <pre><code>type TypeScriptFunction = (...args: any[]) =&gt; any;\n</code></pre>"},{"location":"api/types/#helper-types","title":"Helper Types","text":""},{"location":"api/types/#joboutputsreftoutputs","title":"<code>JobOutputsRef&lt;TOutputs&gt;</code>","text":"<p>Type-safe reference to job outputs.</p> <pre><code>type JobOutputsRef&lt;TOutputs extends Record&lt;string, unknown&gt;&gt; = {\n  id: JobId;\n  outputs: {\n    [K in keyof TOutputs]: string;\n  };\n};\n</code></pre>"},{"location":"api/types/#stepoutputstoutputs","title":"<code>StepOutputs&lt;TOutputs&gt;</code>","text":"<p>Type-safe reference to step outputs.</p> <pre><code>type StepOutputs&lt;TOutputs extends Record&lt;string, unknown&gt;&gt; = {\n  outputs: {\n    [K in keyof TOutputs]: string;\n  };\n};\n</code></pre>"},{"location":"api/types/#type-aliases","title":"Type Aliases","text":"<p>For backward compatibility, several interfaces have type aliases:</p> <pre><code>type WorkflowConfig = IWorkflowConfig;\ntype WorkflowTrigger = IWorkflowTrigger;\ntype Job = IJob;\ntype Step = IStep;\ntype JobDefaults = IJobDefaults;\ntype TypeScriptStepOptions = ITypeScriptStepOptions;\n</code></pre>"},{"location":"api/types/#using-types-in-your-code","title":"Using Types in Your Code","text":"<p>Most types are exported from the main package and can be imported:</p> <pre><code>import type {\n  IWorkflowConfig,\n  IJob,\n  IStep,\n  Runner,\n  JobId\n} from \"ts-actions\";\n</code></pre> <p>However, most users don't need to import these types directly - the classes handle them internally. Type imports are mainly useful for: - Type annotations in custom functions - Creating typed wrappers or utilities - Advanced type manipulation</p>"},{"location":"api/workflow/","title":"Workflow","text":"<p>The <code>Workflow</code> class is the main entry point for creating GitHub Actions workflows. It provides a fluent API for configuring workflow triggers, jobs, permissions, and other workflow-level settings.</p>"},{"location":"api/workflow/#constructor","title":"Constructor","text":""},{"location":"api/workflow/#new-workflowname-string","title":"<code>new Workflow(name?: string)</code>","text":"<p>Creates a new workflow instance.</p> <p>Parameters: - <code>name</code> (optional): The workflow name as it will appear in GitHub Actions</p> <p>Returns: A new <code>Workflow</code> instance</p> <p>Example:</p> <pre><code>const workflow = new Workflow(\"My CI Workflow\");\n</code></pre>"},{"location":"api/workflow/#methods","title":"Methods","text":""},{"location":"api/workflow/#namename-string-this","title":"<code>name(name: string): this</code>","text":"<p>Sets the workflow name.</p> <p>Parameters: - <code>name</code>: The workflow name</p> <p>Returns: The workflow instance for method chaining</p> <p>Example:</p> <pre><code>workflow.name(\"Updated Workflow Name\");\n</code></pre>"},{"location":"api/workflow/#ontriggers-iworkflowtrigger-this","title":"<code>on(triggers: IWorkflowTrigger): this</code>","text":"<p>Sets workflow triggers. This method merges triggers with any existing ones.</p> <p>Parameters: - <code>triggers</code>: An object containing trigger configurations (see Types for details)</p> <p>Returns: The workflow instance for method chaining</p> <p>Example:</p> <pre><code>workflow.on({\n  push: { branches: [\"main\"] },\n  pull_request: { branches: [\"main\"] }\n});\n</code></pre>"},{"location":"api/workflow/#onpushoptions-ipushtriggeroptions-this","title":"<code>onPush(options?: IPushTriggerOptions): this</code>","text":"<p>Adds a push trigger to the workflow. Replaces any existing push trigger.</p> <p>Parameters: - <code>options</code> (optional): Push trigger options   - <code>branches</code>: Array of branch names to trigger on   - <code>tags</code>: Array of tag names to trigger on   - <code>paths</code>: Array of file paths that must change   - <code>pathsIgnore</code>: Array of file paths to ignore</p> <p>Returns: The workflow instance for method chaining</p> <p>Example:</p> <pre><code>workflow.onPush({\n  branches: [\"main\", \"develop\"],\n  paths: [\"src/**\", \"package.json\"]\n});\n</code></pre>"},{"location":"api/workflow/#onpullrequestoptions-ipullrequesttriggeroptions-this","title":"<code>onPullRequest(options?: IPullRequestTriggerOptions): this</code>","text":"<p>Adds a pull request trigger to the workflow. Replaces any existing pull request trigger.</p> <p>Parameters: - <code>options</code> (optional): Pull request trigger options   - <code>branches</code>: Array of branch names to trigger on   - <code>tags</code>: Array of tag names to trigger on   - <code>paths</code>: Array of file paths that must change   - <code>pathsIgnore</code>: Array of file paths to ignore   - <code>types</code>: Array of PR event types (e.g., \"opened\", \"synchronize\", \"closed\")</p> <p>Returns: The workflow instance for method chaining</p> <p>Example:</p> <pre><code>workflow.onPullRequest({\n  branches: [\"main\"],\n  types: [\"opened\", \"synchronize\"]\n});\n</code></pre>"},{"location":"api/workflow/#onworkflowdispatchinputs-key-string-iworkflowdispatchinput-this","title":"<code>onWorkflowDispatch(inputs?: { [key: string]: IWorkflowDispatchInput }): this</code>","text":"<p>Adds a workflow dispatch (manual) trigger to the workflow. This allows the workflow to be triggered manually from the GitHub Actions UI.</p> <p>Parameters: - <code>inputs</code> (optional): Input definitions for manual workflow dispatch   - Each input should have: <code>description</code>, <code>required</code>, <code>default</code>, <code>type</code>, and optionally <code>options</code> for choice types</p> <p>Returns: The workflow instance for method chaining</p> <p>Example:</p> <pre><code>workflow.onWorkflowDispatch({\n  environment: {\n    description: \"Environment to deploy to\",\n    required: true,\n    type: \"choice\",\n    options: [\"staging\", \"production\"]\n  }\n});\n</code></pre>"},{"location":"api/workflow/#onschedulecron-string-this","title":"<code>onSchedule(cron: string): this</code>","text":"<p>Adds a schedule trigger to the workflow. Can be called multiple times to add multiple schedules.</p> <p>Parameters: - <code>cron</code>: A cron expression defining when the workflow should run</p> <p>Returns: The workflow instance for method chaining</p> <p>Example:</p> <pre><code>workflow.onSchedule(\"0 0 * * *\"); // Daily at midnight\nworkflow.onSchedule(\"0 */6 * * *\"); // Every 6 hours\n</code></pre>"},{"location":"api/workflow/#onrepositorydispatchtypes-string-this","title":"<code>onRepositoryDispatch(types?: string[]): this</code>","text":"<p>Adds a repository dispatch trigger to the workflow. This allows external events to trigger the workflow via the GitHub API.</p> <p>Parameters: - <code>types</code> (optional): Array of event type strings to listen for</p> <p>Returns: The workflow instance for method chaining</p> <p>Example:</p> <pre><code>workflow.onRepositoryDispatch([\"deploy\", \"build\"]);\n</code></pre>"},{"location":"api/workflow/#onworkflowcalloptions-iworkflowcalloptions-this","title":"<code>onWorkflowCall(options?: IWorkflowCallOptions): this</code>","text":"<p>Makes the workflow reusable by other workflows (workflow_call).</p> <p>Parameters: - <code>options</code> (optional): Workflow call options   - <code>inputs</code>: Input definitions for the reusable workflow   - <code>outputs</code>: Output definitions   - <code>secrets</code>: Array of secret names that can be passed</p> <p>Returns: The workflow instance for method chaining</p> <p>Example:</p> <pre><code>workflow.onWorkflowCall({\n  inputs: {\n    environment: {\n      description: \"Deployment environment\",\n      required: true,\n      type: \"string\"\n    }\n  },\n  secrets: [\"DEPLOY_KEY\"]\n});\n</code></pre>"},{"location":"api/workflow/#addjobtoutputsjobid-jobid-job-jobtoutputs-this","title":"<code>addJob&lt;TOutputs&gt;(jobId: JobId, job: Job&lt;TOutputs&gt;): this</code>","text":""},{"location":"api/workflow/#addjobtoutputsjobid-jobid-jobfn-job-job-jobtoutputs-this","title":"<code>addJob&lt;TOutputs&gt;(jobId: JobId, jobFn: (job: Job) =&gt; Job&lt;TOutputs&gt;): this</code>","text":"<p>Adds a job to the workflow. Can accept either a Job instance or a function that configures a Job.</p> <p>Parameters: - <code>jobId</code>: The unique identifier for the job - <code>job</code> or <code>jobFn</code>: Either a Job instance or a function that receives a Job and returns a configured Job</p> <p>Returns: The workflow instance for method chaining</p> <p>Example:</p> <pre><code>// Using a function\nworkflow.addJob(\"build\", (job) =&gt;\n  job.runsOn(\"ubuntu-latest\").addStep(/* ... */)\n);\n\n// Using a Job instance\nconst myJob = new Job(\"ubuntu-latest\")\n  .addStep(/* ... */);\nworkflow.addJob(\"build\", myJob);\n</code></pre>"},{"location":"api/workflow/#envvariables-key-string-string-this","title":"<code>env(variables: { [key: string]: string }): this</code>","text":"<p>Sets environment variables for the workflow. These will be available to all jobs in the workflow.</p> <p>Parameters: - <code>variables</code>: An object mapping environment variable names to their values</p> <p>Returns: The workflow instance for method chaining</p> <p>Example:</p> <pre><code>workflow.env({\n  NODE_ENV: \"production\",\n  API_URL: \"https://api.example.com\"\n});\n</code></pre>"},{"location":"api/workflow/#defaultsdefaults-ijobdefaults-this","title":"<code>defaults(defaults: IJobDefaults): this</code>","text":"<p>Sets default values for jobs in the workflow.</p> <p>Parameters: - <code>defaults</code>: Default job settings   - <code>run</code>: Default run settings     - <code>shell</code>: Default shell     - <code>working-directory</code>: Default working directory</p> <p>Returns: The workflow instance for method chaining</p> <p>Example:</p> <pre><code>workflow.defaults({\n  run: {\n    shell: \"bash\",\n    \"working-directory\": \"./src\"\n  }\n});\n</code></pre>"},{"location":"api/workflow/#permissionspermissions-iworkflowpermissions-this","title":"<code>permissions(permissions: IWorkflowPermissions): this</code>","text":"<p>Sets permissions for the workflow. This controls what the GitHub token can access.</p> <p>Parameters: - <code>permissions</code>: An object mapping permission names to access levels (\"read\", \"write\", or \"none\")</p> <p>Returns: The workflow instance for method chaining</p> <p>Example:</p> <pre><code>workflow.permissions({\n  contents: \"read\",\n  packages: \"write\",\n  \"pull-requests\": \"write\"\n});\n</code></pre>"},{"location":"api/workflow/#runnamename-string-this","title":"<code>runName(name: string): this</code>","text":"<p>Sets the run name for workflow runs. This is what appears in the GitHub Actions UI.</p> <p>Parameters: - <code>name</code>: The run name (can include GitHub Actions expressions)</p> <p>Returns: The workflow instance for method chaining</p> <p>Example:</p> <pre><code>workflow.runName(\"${{ github.workflow }}: ${{ github.event.head_commit.message }}\");\n</code></pre> <p>See Run Name Helpers for helper functions.</p>"},{"location":"api/workflow/#tojson-iworkflowconfig","title":"<code>toJSON(): IWorkflowConfig</code>","text":"<p>Converts the workflow to its JSON configuration format. This is used internally by the synthesis functions.</p> <p>Returns: The workflow configuration object</p> <p>Example:</p> <pre><code>const config = workflow.toJSON();\nconsole.log(config.name); // \"My Workflow\"\n</code></pre>"},{"location":"api/workflow/#complete-example","title":"Complete Example","text":"<pre><code>import { Workflow, Job, Step } from \"ts-actions\";\n\nconst workflow = new Workflow(\"CI/CD Pipeline\")\n  .onPush({ branches: [\"main\"] })\n  .onPullRequest({ branches: [\"main\"] })\n  .onWorkflowDispatch({\n    environment: {\n      description: \"Environment to deploy to\",\n      required: true,\n      type: \"choice\",\n      options: [\"staging\", \"production\"]\n    }\n  })\n  .env({ NODE_ENV: \"production\" })\n  .permissions({\n    contents: \"read\",\n    packages: \"write\"\n  })\n  .addJob(\"test\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .addStep((step) =&gt;\n        step.name(\"Run tests\").run(\"npm test\")\n      )\n  )\n  .addJob(\"deploy\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .needs(\"test\")\n      .addStep((step) =&gt;\n        step.name(\"Deploy\").run(\"npm run deploy\")\n      )\n  );\n</code></pre>"},{"location":"examples/advanced/","title":"Advanced Examples","text":"<p>This page contains advanced examples demonstrating complex patterns and features of ts-actions.</p>"},{"location":"examples/advanced/#job-outputs-with-type-safety","title":"Job Outputs with Type Safety","text":"<p>Using job outputs with full type safety:</p> <pre><code>import {\n  Workflow,\n  Job,\n  Step,\n  needs,\n  setOutput,\n  synthesize\n} from \"ts-actions\";\n\nconst buildJob = new Job(\"ubuntu-latest\")\n  .name(\"Build\")\n  .outputs({\n    artifact: \"${{ steps.build.outputs.path }}\",\n    version: \"${{ steps.version.outputs.version }}\",\n    sha: \"${{ github.sha }}\"\n  })\n  .addStep((step) =&gt;\n    step\n      .id(\"build\")\n      .name(\"Build application\")\n      .run([\n        \"npm run build\",\n        setOutput(\"path\", \"./dist/app.zip\")\n      ].join(\"\\n\"))\n  )\n  .addStep((step) =&gt;\n    step\n      .id(\"version\")\n      .name(\"Get version\")\n      .run([\n        \"VERSION=$(node -p \\\"require('./package.json').version\\\")\",\n        setOutput(\"version\", \"$VERSION\")\n      ].join(\"\\n\"))\n  );\n\nconst deployJob = new Job(\"ubuntu-latest\")\n  .name(\"Deploy\")\n  .needs(needs(buildJob))\n  .addStep((step) =&gt;\n    step\n      .name(\"Deploy\")\n      .run(`echo \"Deploying version ${needs(buildJob).outputs.version}\"`)\n  );\n\nconst workflow = new Workflow(\"Build and Deploy\")\n  .onPush({ branches: [\"main\"] })\n  .addJob(\"build\", buildJob)\n  .addJob(\"deploy\", deployJob);\n\nawait synthesize(workflow, \".github/workflows\");\n</code></pre>"},{"location":"examples/advanced/#typescript-function-steps","title":"TypeScript Function Steps","text":"<p>Using TypeScript functions directly in workflow steps:</p> <pre><code>import {\n  Workflow,\n  Job,\n  Step,\n  expr,\n  synthesize\n} from \"ts-actions\";\n\nfunction processData(\n  input: string,\n  multiplier: number,\n  prefix?: string\n): string {\n  const processed = input.repeat(multiplier);\n  return prefix ? `${prefix}: ${processed}` : processed;\n}\n\nfunction validateInput(input: string): boolean {\n  return input.length &gt; 0 &amp;&amp; /^[a-zA-Z0-9]+$/.test(input);\n}\n\nconst workflow = new Workflow(\"TypeScript Functions\")\n  .onPush({ branches: [\"main\"] })\n  .addJob(\"process\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .addStep((step) =&gt;\n        step\n          .name(\"Process Data\")\n          .runTypeScript(\n            processData,\n            { nodeVersion: \"20\" },\n            \"test\",\n            3,\n            \"Result\"\n          )\n      )\n      .addStep((step) =&gt;\n        step\n          .name(\"Validate\")\n          .runTypeScript(\n            validateInput,\n            expr(\"${{ github.event.inputs.data }}\")\n          )\n      )\n  );\n\nawait synthesize(workflow, \".github/workflows\");\n</code></pre>"},{"location":"examples/advanced/#reusable-workflows","title":"Reusable Workflows","text":"<p>Creating reusable workflows that can be called by other workflows:</p> <pre><code>import { Workflow, synthesize } from \"ts-actions\";\n\nconst reusableWorkflow = new Workflow(\"Reusable Deploy\")\n  .onWorkflowCall({\n    inputs: {\n      environment: {\n        description: \"Environment to deploy to\",\n        required: true,\n        type: \"string\"\n      },\n      version: {\n        description: \"Version to deploy\",\n        required: false,\n        type: \"string\",\n        default: \"latest\"\n      }\n    },\n    secrets: [\"DEPLOY_KEY\", \"API_TOKEN\"]\n  })\n  .addJob(\"deploy\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .addStep((step) =&gt;\n        step\n          .name(\"Deploy\")\n          .run(\n            `echo \"Deploying version ${{ inputs.version }} to ${{ inputs.environment }}\"`\n          )\n      )\n  );\n\nawait synthesize(reusableWorkflow, \".github/workflows\");\n</code></pre>"},{"location":"examples/advanced/#scheduled-workflows","title":"Scheduled Workflows","text":"<p>Creating workflows that run on a schedule:</p> <pre><code>import { Workflow, synthesize } from \"ts-actions\";\n\nconst workflow = new Workflow(\"Scheduled Backup\")\n  .onSchedule(\"0 2 * * *\") // Daily at 2 AM\n  .addJob(\"backup\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .addStep((step) =&gt;\n        step\n          .name(\"Backup Database\")\n          .run(\"npm run backup:database\")\n      )\n  );\n\nawait synthesize(workflow, \".github/workflows\");\n</code></pre>"},{"location":"examples/advanced/#concurrency-control","title":"Concurrency Control","text":"<p>Using concurrency to prevent overlapping runs:</p> <pre><code>import { Workflow, synthesize } from \"ts-actions\";\n\nconst workflow = new Workflow(\"Deploy\")\n  .onPush({ branches: [\"main\"] })\n  .addJob(\"deploy\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .concurrency(\"deployment-${{ github.ref }}\", true)\n      .addStep((step) =&gt;\n        step.name(\"Deploy\").run(\"npm run deploy\")\n      )\n  );\n\nawait synthesize(workflow, \".github/workflows\");\n</code></pre>"},{"location":"examples/advanced/#custom-run-names","title":"Custom Run Names","text":"<p>Using helper functions to create informative run names:</p> <pre><code>import {\n  Workflow,\n  defaultRunName,\n  runNameWithSha,\n  customRunName,\n  synthesize\n} from \"ts-actions\";\n\n// Using default run name\nconst workflow1 = new Workflow(\"CI\")\n  .runName(defaultRunName())\n  .onPush({ branches: [\"main\"] })\n  .addJob(\"test\", (job) =&gt; /* ... */);\n\n// Using SHA in run name\nconst workflow2 = new Workflow(\"CI\")\n  .runName(runNameWithSha())\n  .onPush({ branches: [\"main\"] })\n  .addJob(\"test\", (job) =&gt; /* ... */);\n\n// Custom run name\nconst workflow3 = new Workflow(\"CI\")\n  .runName(\n    customRunName(\n      \"${{ github.workflow }} - PR #${{ github.event.pull_request.number }}\"\n    )\n  )\n  .onPullRequest()\n  .addJob(\"test\", (job) =&gt; /* ... */);\n\nawait synthesize(workflow1, \".github/workflows\");\nawait synthesize(workflow2, \".github/workflows\");\nawait synthesize(workflow3, \".github/workflows\");\n</code></pre>"},{"location":"examples/advanced/#multiple-workflows-in-one-file","title":"Multiple Workflows in One File","text":"<p>Generating multiple workflows from a single file:</p> <pre><code>import {\n  Workflow,\n  synthesizeMultiple\n} from \"ts-actions\";\n\nconst ciWorkflow = new Workflow(\"CI\")\n  .onPush({ branches: [\"main\"] })\n  .addJob(\"test\", (job) =&gt; /* ... */);\n\nconst deployWorkflow = new Workflow(\"Deploy\")\n  .onWorkflowDispatch()\n  .addJob(\"deploy\", (job) =&gt; /* ... */);\n\nconst lintWorkflow = new Workflow(\"Lint\")\n  .onPullRequest()\n  .addJob(\"lint\", (job) =&gt; /* ... */);\n\nawait synthesizeMultiple(\n  [\n    { workflow: ciWorkflow },\n    { workflow: deployWorkflow, filename: \"production-deploy\" },\n    { workflow: lintWorkflow }\n  ],\n  \".github/workflows\"\n);\n</code></pre>"},{"location":"examples/advanced/#complex-matrix-strategy","title":"Complex Matrix Strategy","text":"<p>Advanced matrix strategy with multiple dimensions:</p> <pre><code>import { Workflow, synthesize } from \"ts-actions\";\n\nconst workflow = new Workflow(\"Cross-Platform Test\")\n  .onPush({ branches: [\"main\"] })\n  .addJob(\"test\", (job) =&gt;\n    job\n      .runsOn(\"${{ matrix.os }}\")\n      .strategy({\n        matrix: {\n          os: [\"ubuntu-latest\", \"windows-latest\", \"macos-latest\"],\n          node: [\"18\", \"20\", \"22\"],\n          test-suite: [\"unit\", \"integration\", \"e2e\"]\n        },\n        \"fail-fast\": false,\n        \"max-parallel\": 5\n      })\n      .addStep((step) =&gt;\n        step\n          .name(\"Setup Node.js ${{ matrix.node }}\")\n          .uses(\"actions/setup-node@v4\")\n          .with({ \"node-version\": \"${{ matrix.node }}\" })\n      )\n      .addStep((step) =&gt;\n        step\n          .name(\"Run ${{ matrix.test-suite }} tests\")\n          .run(`npm run test:${{ matrix.test-suite }}`)\n      )\n  );\n\nawait synthesize(workflow, \".github/workflows\");\n</code></pre>"},{"location":"examples/advanced/#permissions-and-security","title":"Permissions and Security","text":"<p>Setting specific permissions for workflows:</p> <pre><code>import { Workflow, synthesize } from \"ts-actions\";\n\nconst workflow = new Workflow(\"Secure Deploy\")\n  .onPush({ branches: [\"main\"] })\n  .permissions({\n    contents: \"read\",\n    packages: \"write\",\n    \"pull-requests\": \"read\",\n    \"id-token\": \"write\" // Required for OIDC\n  })\n  .addJob(\"deploy\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .addStep((step) =&gt;\n        step\n          .name(\"Authenticate\")\n          .uses(\"aws-actions/configure-aws-credentials@v4\")\n          .with({\n            \"role-to-assume\": \"${{ secrets.AWS_ROLE }}\",\n            \"aws-region\": \"us-east-1\"\n          })\n      )\n      .addStep((step) =&gt;\n        step.name(\"Deploy\").run(\"npm run deploy\")\n      )\n  );\n\nawait synthesize(workflow, \".github/workflows\");\n</code></pre>"},{"location":"examples/basic/","title":"Basic Examples","text":"<p>This page contains basic examples of using ts-actions to create GitHub Actions workflows.</p>"},{"location":"examples/basic/#simple-ci-workflow","title":"Simple CI Workflow","text":"<p>A basic continuous integration workflow that runs on every push:</p> <pre><code>import { Workflow, Job, Step, synthesize } from \"ts-actions\";\n\nconst workflow = new Workflow(\"CI\")\n  .onPush({ branches: [\"main\", \"develop\"] })\n  .addJob(\"test\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .addStep((step) =&gt;\n        step\n          .name(\"Checkout code\")\n          .uses(\"actions/checkout@v4\")\n      )\n      .addStep((step) =&gt;\n        step\n          .name(\"Setup Node.js\")\n          .uses(\"actions/setup-node@v4\")\n          .with({ \"node-version\": \"20\" })\n      )\n      .addStep((step) =&gt;\n        step\n          .name(\"Install dependencies\")\n          .run(\"npm ci\")\n      )\n      .addStep((step) =&gt;\n        step\n          .name(\"Run tests\")\n          .run(\"npm test\")\n      )\n  );\n\nawait synthesize(workflow, \".github/workflows\");\n</code></pre>"},{"location":"examples/basic/#multi-job-workflow","title":"Multi-Job Workflow","text":"<p>A workflow with multiple jobs that run in parallel:</p> <pre><code>import { Workflow, synthesize } from \"ts-actions\";\n\nconst workflow = new Workflow(\"Quality Checks\")\n  .onPullRequest()\n  .addJob(\"lint\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .addStep((step) =&gt;\n        step.name(\"Run linter\").run(\"npm run lint\")\n      )\n  )\n  .addJob(\"test\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .addStep((step) =&gt;\n        step.name(\"Run tests\").run(\"npm test\")\n      )\n  )\n  .addJob(\"type-check\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .addStep((step) =&gt;\n        step.name(\"Type check\").run(\"npm run type-check\")\n      )\n  );\n\nawait synthesize(workflow, \".github/workflows\");\n</code></pre>"},{"location":"examples/basic/#job-dependencies","title":"Job Dependencies","text":"<p>A workflow where jobs depend on each other:</p> <pre><code>import { Workflow, Job, Step, needs, synthesize } from \"ts-actions\";\n\nconst buildJob = new Job(\"ubuntu-latest\")\n  .name(\"Build\")\n  .addStep((step) =&gt;\n    step.name(\"Build application\").run(\"npm run build\")\n  );\n\nconst testJob = new Job(\"ubuntu-latest\")\n  .name(\"Test\")\n  .needs(needs(buildJob))\n  .addStep((step) =&gt;\n    step.name(\"Run tests\").run(\"npm test\")\n  );\n\nconst deployJob = new Job(\"ubuntu-latest\")\n  .name(\"Deploy\")\n  .needs(needs(buildJob))\n  .addStep((step) =&gt;\n    step.name(\"Deploy\").run(\"npm run deploy\")\n  );\n\nconst workflow = new Workflow(\"Build and Deploy\")\n  .onPush({ branches: [\"main\"] })\n  .addJob(\"build\", buildJob)\n  .addJob(\"test\", testJob)\n  .addJob(\"deploy\", deployJob);\n\nawait synthesize(workflow, \".github/workflows\");\n</code></pre>"},{"location":"examples/basic/#matrix-strategy","title":"Matrix Strategy","text":"<p>Running a job with multiple configurations:</p> <pre><code>import { Workflow, synthesize } from \"ts-actions\";\n\nconst workflow = new Workflow(\"Test Matrix\")\n  .onPush({ branches: [\"main\"] })\n  .addJob(\"test\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .strategy({\n        matrix: {\n          node: [\"18\", \"20\", \"22\"],\n          os: [\"ubuntu-latest\", \"windows-latest\", \"macos-latest\"]\n        },\n        \"fail-fast\": false\n      })\n      .addStep((step) =&gt;\n        step\n          .name(\"Setup Node.js ${{ matrix.node }}\")\n          .uses(\"actions/setup-node@v4\")\n          .with({ \"node-version\": \"${{ matrix.node }}\" })\n      )\n      .addStep((step) =&gt;\n        step.name(\"Run tests\").run(\"npm test\")\n      )\n  );\n\nawait synthesize(workflow, \".github/workflows\");\n</code></pre>"},{"location":"examples/basic/#manual-workflow-dispatch","title":"Manual Workflow Dispatch","text":"<p>A workflow that can be triggered manually:</p> <pre><code>import { Workflow, synthesize } from \"ts-actions\";\n\nconst workflow = new Workflow(\"Deploy\")\n  .onWorkflowDispatch({\n    environment: {\n      description: \"Environment to deploy to\",\n      required: true,\n      type: \"choice\",\n      options: [\"staging\", \"production\"]\n    },\n    version: {\n      description: \"Version to deploy\",\n      required: false,\n      type: \"string\"\n    }\n  })\n  .addJob(\"deploy\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .if(\"github.event.inputs.environment != ''\")\n      .addStep((step) =&gt;\n        step\n          .name(\"Deploy to ${{ github.event.inputs.environment }}\")\n          .run(\"echo 'Deploying...'\")\n      )\n  );\n\nawait synthesize(workflow, \".github/workflows\");\n</code></pre>"},{"location":"examples/basic/#conditional-steps","title":"Conditional Steps","text":"<p>Using conditions to control when steps run:</p> <pre><code>import { Workflow, synthesize } from \"ts-actions\";\n\nconst workflow = new Workflow(\"Conditional Workflow\")\n  .onPush({ branches: [\"main\"] })\n  .addJob(\"build\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .addStep((step) =&gt;\n        step.name(\"Build\").run(\"npm run build\")\n      )\n      .addStep((step) =&gt;\n        step\n          .name(\"Deploy to staging\")\n          .if(\"github.ref == 'refs/heads/main'\")\n          .run(\"npm run deploy:staging\")\n      )\n      .addStep((step) =&gt;\n        step\n          .name(\"Deploy to production\")\n          .if(\"github.ref == 'refs/heads/production'\")\n          .run(\"npm run deploy:production\")\n      )\n  );\n\nawait synthesize(workflow, \".github/workflows\");\n</code></pre>"},{"location":"examples/basic/#environment-variables","title":"Environment Variables","text":"<p>Using environment variables at different levels:</p> <pre><code>import { Workflow, synthesize } from \"ts-actions\";\n\nconst workflow = new Workflow(\"Environment Example\")\n  .onPush({ branches: [\"main\"] })\n  .env({\n    NODE_ENV: \"production\",\n    LOG_LEVEL: \"info\"\n  })\n  .addJob(\"build\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .env({\n        BUILD_TARGET: \"production\"\n      })\n      .addStep((step) =&gt;\n        step\n          .name(\"Build\")\n          .env({\n            DEBUG: \"true\"\n          })\n          .run(\"npm run build\")\n      )\n  );\n\nawait synthesize(workflow, \".github/workflows\");\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>ts-actions is available for both TypeScript/JavaScript and Python.</p>"},{"location":"getting-started/installation/#typescriptjavascript","title":"TypeScript/JavaScript","text":"<p>Install ts-actions using npm:</p> <pre><code>npm install ts-actions\n</code></pre> <p>Or using yarn:</p> <pre><code>yarn add ts-actions\n</code></pre> <p>Or using pnpm:</p> <pre><code>pnpm add ts-actions\n</code></pre>"},{"location":"getting-started/installation/#python","title":"Python","text":"<p>Install ts-actions using pip:</p> <pre><code>pip install ts-actions\n</code></pre>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Node.js: Version 18 or higher (for TypeScript/JavaScript)</li> <li>Python: Version 3.8 or higher (for Python)</li> </ul>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Once installed, head over to the Quick Start guide to create your first workflow!</p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide will help you create your first GitHub Actions workflow using ts-actions.</p>"},{"location":"getting-started/quick-start/#basic-workflow","title":"Basic Workflow","text":"<p>Let's create a simple CI workflow that runs tests on every push:</p> <pre><code>import { Workflow, Job, Step, synthesize } from \"ts-actions\";\n\nconst workflow = new Workflow(\"CI\")\n  .onPush({ branches: [\"main\"] })\n  .addJob(\"test\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .addStep((step) =&gt;\n        step\n          .name(\"Checkout code\")\n          .uses(\"actions/checkout@v4\")\n      )\n      .addStep((step) =&gt;\n        step\n          .name(\"Setup Node.js\")\n          .uses(\"actions/setup-node@v4\")\n          .with({ \"node-version\": \"20\" })\n      )\n      .addStep((step) =&gt;\n        step\n          .name(\"Install dependencies\")\n          .run(\"npm install\")\n      )\n      .addStep((step) =&gt;\n        step\n          .name(\"Run tests\")\n          .run(\"npm test\")\n      )\n  );\n\n// Synthesize to YAML file\nawait synthesize(workflow, \".github/workflows\");\n</code></pre> <p>This will generate a <code>.github/workflows/ci.yml</code> file with the following content:</p> <pre><code>name: CI\non:\n  push:\n    branches:\n      - main\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20\n      - name: Install dependencies\n        run: npm install\n      - name: Run tests\n        run: npm test\n</code></pre>"},{"location":"getting-started/quick-start/#adding-more-jobs","title":"Adding More Jobs","text":"<p>You can add multiple jobs to a workflow:</p> <pre><code>const workflow = new Workflow(\"CI\")\n  .onPush({ branches: [\"main\"] })\n  .addJob(\"lint\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .addStep((step) =&gt;\n        step.name(\"Run linter\").run(\"npm run lint\")\n      )\n  )\n  .addJob(\"test\", (job) =&gt;\n    job\n      .runsOn(\"ubuntu-latest\")\n      .addStep((step) =&gt;\n        step.name(\"Run tests\").run(\"npm test\")\n      )\n  );\n</code></pre>"},{"location":"getting-started/quick-start/#job-dependencies","title":"Job Dependencies","text":"<p>You can make jobs depend on other jobs:</p> <pre><code>import { needs } from \"ts-actions\";\n\nconst lintJob = new Job(\"ubuntu-latest\")\n  .addStep((step) =&gt; step.name(\"Lint\").run(\"npm run lint\"));\n\nconst testJob = new Job(\"ubuntu-latest\")\n  .needs(needs(lintJob))  // Wait for lint to complete\n  .addStep((step) =&gt; step.name(\"Test\").run(\"npm test\"));\n\nconst workflow = new Workflow(\"CI\")\n  .onPush({ branches: [\"main\"] })\n  .addJob(\"lint\", lintJob)\n  .addJob(\"test\", testJob);\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Check out the API Reference for detailed documentation</li> <li>See more Examples for advanced patterns</li> </ul>"}]}